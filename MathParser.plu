# 07/10/16 Pluto0.0.83
# MathScanner (and maybe MathParser) shouldn't have been classes, but I did it for simplicity
module MathParser

# SCANNING
enum TokenType: Identfier, Number, Operator, Punctuator, Newline, Others
type Token (str =: Str, kind =: TokenType)

let priv input =: Str
mut priv charIndex =: Int

func priv getChar():
    if charIndex++ < input.length:
        input[charIndex]
    Str.nil
..

# remember tokens are the least meaningful things that make up complex structures
func scan(input =: Str):
    mut tokens =: let Token[]
    glo.input = input
    inputLen = glo.input.length
    charIndex = 0
    let operators = '=-+*/^'
    let punctuators = ':}(),'
    mut char =: Str
    loop: # if the nil is returned which means end of input, loop and function are exited
        char = getChar()~
        # Whitespace
        while char == ' ':
            char = getChar()~break
        # Identifier
        if isAlpha(char) | char == '_':
            mut idenStr =: char
            while isAlNum(char) | char == '_':
                idenStr += char
                char =: getChar()~break
            ..
            tokens += Token(idenStr, Identifier)
        ..
        # Number
        mut numStr =: Str
        while isDigit(char):
            numStr += char
            char =: getChar()~break
        ..
        if !numStr.empty(): tokens += Token(numStr, Number)
        # Operator
        if char in operators:
            tokens += Token(idenStr, Operator)
        # Punctuator
        if char in punctuators:
            tokens += Token(idenStr, Punctuator)
        # NewLine
        if char == '\n':
            tokens += Token(char, Newline)
        elif char == '\r':
            char += getChar()~''
            if char == '\n': tokens += Token('\r\n', Newline)
            char = nl
        ..
        # Nil
        if !char~: break # If nil then there is no more content to scan
        # Others
        token += Token(char, Others)
    ..
    tokens
..


# PARSING
type ab ExprAST
type BinExprAST[ExprAST]:
    let operator =: String
    let lhs =: ExprAST
    let rhs =: ExprAST
    func (operator, lhs, rhs)
..
type FuncCallExprAST[ExprAST]:
    let callee =: IdenExprAST
    let args =: ExprAST[]
    func (callee, args)
..
type NumExprAST[ExprAST]:
    let value =: F64
    func (value)
..
type IdenExprAST[ExprAST]:
    let name =: Str
    func (name)
..
type SyntaxError((errorMsg =: Str))[Error]
type NewlineBounce((errorMsg =: Str))[Bounce]

let priv tokens =: Token[]
mut priv tokenIndex =: 0
mut priv curToken =: Token
let priv funcNames =: ['sq', 'cu', 'rt']
let priv binOpPrecedence =: [
    "=", 10 |
    '+', 20 |
    '-', 20 |
    '*', 30 |
    '/', 30 |
    '^', 40
]

func priv getToken():
    if tokenIndex++ < tokens.length:
        curToken = tokens[tokenIndex]
    else: curToken = Token.nil
..


func parse(tokens =: Token[]):
    glo.tokens =: tokens
    getToken()
    if !curToken~ | curToken.kind == Newline: raise SyntaxError("Nothing to parse!")
    let exprAST =: parseExpr(false)
    rt let asts =: exprAST
..

#=
func priv lookAhead()Token:
    if tokenIndex + 1 < tokens.length:
        tokens[tokenIndex + 1]
    else: Token.nil
..
=#


# GRAMMAR
# idenExpr ::= iden rhs
# numExpr ::= num rhs
# parensExpr ::= '(' expr ')' rhs
# rhs ::= op expr | ϵ
# op ::= '=' | '+' | '-' | '*' | '/' | '^'
# expr ::= idenExpr | numExpr | parensExpr | funcExpr
# funcName := 'sq' | 'cu' | 'rt'
# funcCallExpr ::= ':' funcName params
# params ::= '{' expr args '}' | ϵ
# args ::= ',' expr | args | ϵ
# ----------------------------------------
# a
# a + ...
# 1
# 1 + ...
# ( ... )
# :func{1, a}
# :func{24} + ...
# \n
# EXAMPLE AST STRUCTURE
# a + 1 - 2
# binAST -> op idenAST exprAST (-> binAST (-> op numAST numAST ) )
func priv parsePrimary(mid =: Bool)ExprAST:
    # idenExpr ::= iden rhs
    # numExpr ::= num rhs
    # parensExpr ::= '(' expr ')' rhs
    # rhs ::= op expr | ϵ
    # expr ::= idenExpr | numExpr | parensExpr | funcExpr
    let exprAST =: ExprAST
    match (curToken.kind):
        case Identfier: exprAST = parseIdenExpr()
        case Number: exprAST = parseNumExpr()
        case Punctuator:
            if curToken.str == '(': exprAST = parseParensExpr()
            if curToken.str == ':': exprAST = parseFuncCallExpr()
        case NewLine:
            if mid == true: raise SyntaxError("Expected an expression!") # if mid expression
            else: raise NewlineBounce() # if start of line
        case Others:
            raise SyntaxError("Expected an expression!")
        ..
    ..
    rt exprAST
..

func priv parseExpr(mid =: Bool)ExprAST:
    let lhs =: parsePrimary(mid)
    if curtoken~ | curToken.kind != Newline:
        rt parseBinExpr(0, lhs)
    rt lhs
..

func priv parseIdenExpr()ExprAST:
    # idenExpr ::= iden rhs
    # rhs ::= op expr | ϵ
    # a
    # a + ...
    let idenExprAST =: IdenExprAST(curToken.str)
    getToken() # eat iden
    rt idenExprAST
..

func priv parseNumExpr()NumExprAST:
    # numExpr ::= num rhs
    # rhs ::= op expr | ϵ
    # 1
    # 1 + ...
    let numExprAST =: NumExprAST(curToken.str.toDouble())
    getToken() # eat num
    rt numExprAST
..

func priv parseParensExpr():
    # parensExpr ::= '(' expr ')' rhs
    # rhs ::= op expr | ϵ
    # ( ... )
    # ( ... ) + ...
    getToken() # eat '('
    let exprAST =: parseExpr(true)
    if curToken.str != ')': raise SyntaxError("Expected a ')'")
    getToken() # eat ')'
    rt exprAST
..


func priv parseFuncCallExpr()FuncCallExprAST:
    # funcName := 'sq' | 'cu' | 'rt'
    # funcCallExpr ::= ':' funcName params
    # params ::= '{' expr args '}' | ϵ
    # args ::= ',' expr | args | ϵ
    # :func{1, a}
    # :func{24} + ...
    getToken() # eat ':'
    if curToken.str not in funcNames: raise SyntaxError("Expected a function name!")
    let funcName =: curToken.str
    let args =: ExprAST
    getToken() # eat funcName
    if curToken.str != '{': raise SyntaxError("Expected a '{'!")
    getToken() # eat '{'
    while curToken.str != '}':
        args += parseExpr(true)
        if curToken.str == ',':
            getToken() # eat ','
            if !curToken~ | curToken.kind == NewLine | curToken.str == '}': raise SyntaxError("Expected an expression!")
        ..
        if !curToken~ | curToken.kind == NewLine: raise SyntaxError("Expected a '}'!")
    ..
    getToken() # eat '}'
    rt funcCallExprAST =: FuncCallExprAST(funcName, args)
..

func priv parseBinExpr(op1prec =: Int, lhs =: ExprAST)BinExprAST:
    if curToken.str == ",": # for functions
        rt lhs # step out. "," is not eaten
    ..
    # op1 lhs op2 rhs op3
    loop:
        if curToken.kind != Operator: raise SyntaxError("Expected an binary operator!")
        var op2 = curToken.str
        var op2prec = binOpPrecedence[op2]

        if op2prec < op1prec: # op1[>=] lhs) op2[<]
            rt lhs
        getToken() # eat op2

        var rhs =: parsePrimary(true)

        if !curToken~ | curToken.kind == Operator: raise SyntaxError("Expected an binary operator!")
        var op3 = curToken.str
        var op3prec = binOpPrecedence[op3]

        if op2prec < op3prec: # op2[<] (rhs op3[>=]
            rhs = parseBinExpr(op2prec, rhs)
        lhs = BinExprAST(op2, lhs, rhs)
    ..
..


# CODEGEN
enum OpCode: DLOAD, DSTORE, DADD, DSUB, DMUL, DDIV, DEXP, DROOT, GOTO, DPUSH, DCMPEQ

type ByteCode(opCode =: OpCode, String param)

let asts =: ExprAST[]

func codegen() # TODO TODO


func show(ast =: ExprAST):
    # Printing using infix notation for legibility
    if ast === NumExprAST:
        put(.value)
    elif ast === IdenExprAST:
        put(.name)
    elif ast === BinExprAST:
        show(.lhs)
        put(" [.op] ")
        show(.rhs)
    elif ast === FuncCallExprAST:
        put("{ ")
        put(.callee)
        put(" -> ")
        for x thru .args:
            show(x)
            print(",")
        ..
        put(" }")
    ..
..

# ENTRY
func main():
    mut asts =: let ExprAST[]
    loop:
        [try]
        print("mathopia >>> ")
        mut input =: scan() # scans the line
        asts += parse(scan(input))
        catch s =: SyntaxError:
            print(s.errorMsg)
            next
        catch n =: NewlineBounce:
            next
    ..
..
